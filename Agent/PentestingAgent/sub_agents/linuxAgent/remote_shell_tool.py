import requests
import json
import time
from typing import List, Dict, Any, Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def execute_remote_commands(
    commands: List[str],
    host: str = "localhost",
    port: int = 3000,
    endpoint: str = "/executeCommand",
    timeout: int = 30
) -> Dict[str, Any]:
    """
    Execute a list of commands via HTTP POST requests to the remote shell server.
    
    Args:
        commands (List[str]): List of commands to execute
        host (str): Remote host address (default: localhost)
        port (int): HTTP port (default: 3000)
        endpoint (str): API endpoint (default: /executeCommand)
        timeout (int): Request timeout in seconds (default: 30)
    
    Returns:
        Dict[str, Any]: Dictionary containing execution results with the following structure:
        {
            "success": bool,
            "results": List[Dict[str, Any]],
            "error": Optional[str],
            "total_commands": int,
            "successful_commands": int,
            "failed_commands": int
        }
    """
    
    results = {
        "success": False,
        "results": [],
        "error": None,
        "total_commands": len(commands),
        "successful_commands": 0,
        "failed_commands": 0
    }
    
    # Construct the base URL
    base_url = f"http://{host}:{port}{endpoint}"
    
    try:
        logger.info(f"Connecting to remote shell server at {base_url}")
        
        # Execute each command
        for i, command in enumerate(commands):
            command_result = {
                "command": command,
                "command_index": i,
                "success": False,
                "stdout": "",
                "stderr": "",
                "exit_code": None,
                "execution_time": None
            }
            
            try:
                logger.info(f"Executing command {i+1}/{len(commands)}: {command}")
                start_time = time.time()
                
                # Prepare the POST request
                payload = {
                    "command": command
                }
                
                headers = {
                    "Content-Type": "application/json"
                }
                
                # Make the POST request
                response = requests.post(
                    base_url,
                    json=payload,
                    headers=headers,
                    timeout=timeout
                )
                
                execution_time = time.time() - start_time
                
                # Check if request was successful
                if response.status_code == 200:
                    try:
                        # Parse the response
                        response_data = response.json()
                        
                        # Update command result based on response structure
                        command_result.update({
                            "success": response_data.get("success", False),
                            "stdout": response_data.get("stdout", ""),
                            "stderr": response_data.get("stderr", ""),
                            "exit_code": response_data.get("exit_code", 0),
                            "execution_time": execution_time
                        })
                        
                        if command_result["success"]:
                            results["successful_commands"] += 1
                            logger.info(f"Command {i+1} executed successfully")
                        else:
                            results["failed_commands"] += 1
                            logger.warning(f"Command {i+1} failed")
                            
                    except json.JSONDecodeError as e:
                        # If response is not JSON, treat it as stdout
                        command_result.update({
                            "success": True,
                            "stdout": response.text,
                            "stderr": "",
                            "exit_code": 0,
                            "execution_time": execution_time
                        })
                        results["successful_commands"] += 1
                        logger.info(f"Command {i+1} executed successfully (non-JSON response)")
                        
                else:
                    # HTTP error
                    results["failed_commands"] += 1
                    command_result.update({
                        "success": False,
                        "stderr": f"HTTP {response.status_code}: {response.text}",
                        "exit_code": response.status_code,
                        "execution_time": execution_time
                    })
                    logger.error(f"HTTP error {response.status_code} for command {i+1}")
                
            except requests.exceptions.Timeout:
                results["failed_commands"] += 1
                command_result.update({
                    "success": False,
                    "stderr": f"Request timeout after {timeout} seconds",
                    "exit_code": -1,
                    "execution_time": timeout
                })
                logger.error(f"Timeout executing command {i+1}")
                
            except requests.exceptions.ConnectionError:
                results["failed_commands"] += 1
                command_result.update({
                    "success": False,
                    "stderr": f"Connection error: Could not connect to {base_url}",
                    "exit_code": -1,
                    "execution_time": 0
                })
                logger.error(f"Connection error for command {i+1}")
                
            except Exception as e:
                results["failed_commands"] += 1
                command_result.update({
                    "success": False,
                    "stderr": str(e),
                    "exit_code": -1,
                    "execution_time": 0
                })
                logger.error(f"Error executing command {i+1}: {str(e)}")
            
            results["results"].append(command_result)
        
        # Overall success if at least one command succeeded
        results["success"] = results["successful_commands"] > 0
        
    except Exception as e:
        results["error"] = str(e)
        logger.error(f"General error: {str(e)}")
    
    return results

def execute_single_remote_command(
    command: str,
    host: str = "localhost",
    port: int = 3000,
    endpoint: str = "/executeCommand",
    timeout: int = 30
) -> Dict[str, Any]:
    """
    Execute a single command via HTTP POST request to the remote shell server.
    
    Args:
        command (str): Command to execute
        host (str): Remote host address (default: localhost)
        port (int): HTTP port (default: 3000)
        endpoint (str): API endpoint (default: /executeCommand)
        timeout (int): Request timeout in seconds (default: 30)
    
    Returns:
        Dict[str, Any]: Dictionary containing execution result
    """
    return execute_remote_commands(
        commands=[command],
        host=host,
        port=port,
        endpoint=endpoint,
        timeout=timeout
    )

def check_server_status(
    host: str = "localhost",
    port: int = 3000,
    endpoint: str = "/health",
    timeout: int = 10
) -> Dict[str, Any]:
    """
    Check if the remote shell server is running and accessible.
    
    Args:
        host (str): Remote host address (default: localhost)
        port (int): HTTP port (default: 3000)
        endpoint (str): Health check endpoint (default: /health)
        timeout (int): Request timeout in seconds (default: 10)
    
    Returns:
        Dict[str, Any]: Server status information
    """
    try:
        url = f"http://{host}:{port}{endpoint}"
        response = requests.get(url, timeout=timeout)
        
        if response.status_code == 200:
            return {
                "status": "running",
                "message": "Server is running and accessible",
                "url": url,
                "response": response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
            }
        else:
            return {
                "status": "error",
                "message": f"Server responded with status code {response.status_code}",
                "url": url,
                "response": response.text
            }
            
    except requests.exceptions.ConnectionError:
        return {
            "status": "unreachable",
            "message": f"Could not connect to server at {url}",
            "url": url,
            "response": None
        }
    except requests.exceptions.Timeout:
        return {
            "status": "timeout",
            "message": f"Request to {url} timed out",
            "url": url,
            "response": None
        }
    except Exception as e:
        return {
            "status": "error",
            "message": str(e),
            "url": url,
            "response": None
        }

# Example usage and testing
if __name__ == "__main__":
    # Example commands to test
    test_commands = [
        "whoami",
        "pwd",
        "ls -la",
        "echo 'Hello from remote shell'",
        "uname -a"
    ]
    
    print("Remote shell tool ready for use!")
    print("This tool makes HTTP POST requests to localhost:3000/executeCommand")
    print()
    
    # Check server status
    print("Checking server status...")
    status = check_server_status()
    print(f"Server status: {status['status']}")
    print(f"Message: {status['message']}")
    print()
    
    # Test with a simple command
    print("Testing with a simple command...")
    result = execute_single_remote_command("echo 'test'")
    print(f"Result: {result}") 