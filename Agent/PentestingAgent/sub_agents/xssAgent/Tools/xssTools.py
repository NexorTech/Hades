from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import NoAlertPresentException, TimeoutException, WebDriverException
import time
from .utils.getParams import smart_query_param_finder

def check_for_xss_popup(test_url, wait_time=5, headless=True) -> bool:
    """
    Checks if an alert popup appears after visiting the given test URL.
    
    Args:
        test_url (str): The URL with the XSS payload.
        wait_time (int): Seconds to wait after loading the page.
        headless (bool): Whether to run the browser in headless mode.
    
    Returns:
        bool: True if popup detected (XSS vulnerable), False otherwise.
    """
    options = Options()
    if headless:
        options.add_argument("--headless=new")  # Use modern headless mode
    options.add_argument("--disable-blink-features=AutomationControlled")
    options.add_argument("--disable-gpu")
    options.add_argument("--no-sandbox")

    try:
        driver = webdriver.Chrome(options=options)

        print(f"[~] Visiting: {test_url}")
        driver.get(test_url)
        time.sleep(wait_time) 

        try:
            alert = driver.switch_to.alert
            alert_text = alert.text
            print(f"[+] XSS Detected! Alert Message: {alert_text}")
            alert.accept()  
            return True
        except NoAlertPresentException:
            print("[-] No alert popup detected.")
            return False

    except WebDriverException as e:
        print(f"[!] WebDriver error: {e}")
        return False

    finally:
        try:
            driver.quit()
        except:
            pass


import urllib.parse

def ensure_query_param_url(url: str) -> str:
    """
    Ensures the given URL has at least one query parameter.
    If not, tries to find possible injectable parameters and return an updated URL with dummy values.

    Args:
        url (str): The URL to check or update.

    Returns:
        str: URL with at least one query parameter.
    """
    parsed_url = urllib.parse.urlparse(url)
    query_params = urllib.parse.parse_qs(parsed_url.query)

    if query_params:
        return url  # Already has query parameters

    # Discover parameters using smart_query_param_finder
    print("[*] No query parameters found. Trying to discover using smart_query_param_finder...")
    found_params = smart_query_param_finder(url)

    if not found_params:
        print("[-] No parameters could be discovered.")
        return url  # No update possible

    # Construct a new URL with dummy parameters
    dummy_params = {param: "test" for param in found_params}
    new_query = urllib.parse.urlencode(dummy_params)
    updated_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{new_query}"
    print(f"[+] Updated URL with dummy parameters: {updated_url}")
    return updated_url


import urllib.parse

def checkXSSVul(base_url: str, payload: str) -> bool:
    """
    Injects the given payload into all parameters of the URL and checks for XSS vulnerability.

    Args:
        base_url (str): The URL with query params (or generated by `ensure_query_param_url()`).
        payload (str): The XSS payload to test.

    Returns:
        bool: True if vulnerable, False otherwise.
    """
    parsed_url = urllib.parse.urlparse(base_url)
    query_params = urllib.parse.parse_qs(parsed_url.query)

    if not query_params:
        print("[-] No parameters to inject into.")
        return False

    injected_params = {param: payload for param in query_params}
    injected_query = urllib.parse.urlencode(injected_params, doseq=True)
    injected_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{injected_query}"

    print(f"[~] Testing injected URL: {injected_url}")
    return check_for_xss_popup(injected_url)


# print(ensure_query_param_url('https://xss-game.appspot.com/level1/frame'))